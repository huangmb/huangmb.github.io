<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动手实现一个JavaScript的AOP(一)]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAJavaScript%E7%9A%84AOP%2F</url>
    <content type="text"><![CDATA[前言AOP即面向切面编程，简单来说就是可以通过编译期或者运行时在不修改源代码的情况下给程序动态增加功能的一种技术。 AOP应用场景AOP比较典型的应用有：日志记录、性能监控、埋点上报、异常处理等等。对于业务无关的附加功能，直接写到业务代码中也可以实现，但这显然不是一个有”洁癖”程序员的作风；而且这些功能往往需求多变，或者会污染业务代码的实现，掺杂在一起难以维护。无侵入的AOP才是”附加功能”的最佳选择。 Java的AOP实现在Java领域，最负盛名的AOP框架莫过于AspectJ，不论是客户端的Swing项目(编译期织入)，还是Web平台的Spring项目（运行时动态代理），我们都可以见到它的身影。 JavaScript版本的AOP实现？那么在JavaScript上有没有AspectJ这样的框架呢? 笔者目前在开发一个React Native项目，测试妹子要求给她打印页面的一些诸如请求起止时间、数据解析起止时间、视图渲染起止时间之类的性能指标。 面对这样的要求，首先想到的就是通过AOP实现。毕竟这不是产品经理的需求，写到业务也不合适，甚至可能会影响到正式版本的性能；本地单独写个版本，不合入主仓库，这样的话测试妹子明天又来要个版本，又得在新版本上再写一遍（想想好像也不是不可以）。 回到这个”要求”，Google了一番”JavaScript” + “AOP”关键字，并没有找到一个合适的框架┐(ﾟ～ﾟ)┌。 或许并不需要这样一个”框架”呢。庆幸的是，js作为一个语法高度自由的弱类型语言，允许动态增删方法，这不就是各种AOP框架实现的基础么。 于是就有了这篇文章，自己撸一个js版本的AOP实现。 AOP的理论基础和尚念经时间。 AOP一般有以下几个概念： 连接点(JointPoint):能够被拦截的地方，一般是成员方法或者属性，它们都可以称之为连接点。 切点(PointCut):具体定位的连接点，既然每个方法(或属性)都可以作为连接点，我们不可能对所有方法都进行增强，那么被我们匹配用来增强的方法就是切点。 增强/通知(Advice):就是我们用来添加到特定切点上的逻辑代码，用于”增强”原有的功能。 切面(Aspect):切面由切点和增强组成，就是定义你要在”什么地方”以”何种方式”做”什么事”。 而增强(Advice)一般有以下五种类型： 前置(before):也就是在连接点执行前实施增强。 异常(after throw)在连接点抛出异常后实施增强，一般允许拿到连接点抛出的异常。 返回(after return)在连接点正常执行后实施增强，一般允许拿到连接点的返回值。 后置(after (final)):在连接点执行后实施增强，不论连接点是正常返回还是抛出异常，一般拿不到返回值，因为不知道是异常还是返回。 环绕(around)在连接点执行前后实施增强，甚至可以让连接点可选的执行。 动手实现撸起袖子开始干。 实现切点和切面我们知道，JavaScript的对象都有个prototype原型对象，即使是es6的class上定义的属性和方法，其实也是在声明在prototype上。 我们可以通过SomeClass.prototype.methodName找到SomeClass类的MethodName方法，这样，一个最简单的方法名匹配切点就实现了。 我们可以通过修改prototype,重新定义方法，比如:12345678910let target = SomeClass;let pointCut = 'methodName';// 切点let old = target.prototype[pointCut]// 切面target.prototype[pointCut] = function () &#123; // 前置增强 console.log(`method $&#123;pointCut&#125; will be invoke`); old();&#125; 这里为SomeClass类重新定义了methodName方法，在原方法之前加入了一条log语句，这条语句其实就是before类型的增强代码。这段代码就是最简单的前置增强的切面例子。 实现增强/通知在实现具体的增强前，先定义一个匹配切点的方法，目前最简单的版本就是根据方法名直接匹配。1234567891011let findPointCut = (target, pointCut) =&gt; &#123; if (typeof pointCut === 'string') &#123; let func = target.prototype[pointCut]; // 暂不支持属性的aop if (typeof func === 'function') &#123; return func; &#125; &#125; // 暂不支持模糊匹配切点 return null;&#125;; 最终，我们将以下面的结构来提供我们的AOP工具，其中target即为要增强的类，pointCut为要增强的方法名，cb为回调即我们要注入的增强代码。1234567891011121314let aop = &#123; before(target, pointCut, cb) &#123; &#125;, after(target, pointCut, cb) &#123; &#125;, afterReturn(target, pointCut, cb) &#123; &#125;, afterThrow(target, pointCut, cb) &#123; &#125;, around(target, pointCut, cb) &#123; &#125;&#125;;export default aop; 以前置增强为例，我们要给增强代码传递的连接点信息只要最基础的目标类、目标方法、原始参数，便于增强代码识别切面信息。 在连接点信息中还加入了self即当前对象的引用，之所以加入这个信息，是因为当增强代码是一个箭头函数时，后面的apply和call方法无法修改增强代码的this引用，可以通过这个self来访问目标对象的属性；使用function定义的回调可以直接使用this访问目标对象。 1234567891011121314151617before(target, pointCut, cb = emptyFunc) &#123; let old = findPointCut(target, pointCut); if (old) &#123; target.prototype[pointCut] = function () &#123; let self = this; let joinPoint = &#123; target, method: old, args: arguments, self &#125;; cb.apply(self, joinPoint); return old.apply(self, arguments); &#125;; &#125; &#125; 因为后面几种增强跟这个差不太多，可能会出现很多重复代码。现在将所有的增强进行了一个封装，所有类型的增强都融合在advice方法里。整个aop完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990let emptyFunc = () =&gt; &#123;&#125;;let findPointCut = (target, pointCut) =&gt; &#123; if (typeof pointCut === 'string') &#123; let func = target.prototype[pointCut]; // 暂不支持属性的aop if (typeof func === 'function') &#123; return func; &#125; &#125; // 暂不支持模糊匹配切点 return null;&#125;;let advice = (target, pointCut, advice = &#123;&#125;) =&gt; &#123; let old = findPointCut(target, pointCut); if (old) &#123; target.prototype[pointCut] = function () &#123; let self = this; let args = arguments; let joinPoint = &#123; target, method: old, args, self &#125;; let &#123;before, round, after, afterReturn, afterThrow&#125; = advice; // 前置增强 before &amp;&amp; before.apply(self, joinPoint); // 环绕增强 let roundJoinPoint = joinPoint; if (round) &#123; roundJoinPoint = Object.assign(joinPoint, &#123; handle: () =&gt; &#123; return old.apply(self, arguments || args); &#125; &#125;); &#125; else &#123; // 没有声明round增强,直接执行原方法 round = () =&gt; &#123; old.apply(self, args); &#125;; &#125; if (after || afterReturn || afterThrow) &#123; let result = null; let error = null; try &#123; result = round.apply(self, roundJoinPoint); // 返回增强 return afterReturn &amp;&amp; afterReturn.call(self, joinPoint, result) || result; &#125; catch (e) &#123; error = e; // 异常增强 let shouldIntercept = afterThrow &amp;&amp; afterThrow.call(self, joinPoint, e); if (!shouldIntercept) &#123; throw e; &#125; &#125; finally &#123; // 后置增强 after &amp;&amp; after.call(self, joinPoint, result, error); &#125; &#125; else &#123; // 未定义任何后置增强,直接执行原方法 return round.call(self, roundJoinPoint); &#125; &#125;; &#125;&#125;;let aop = &#123; before(target, pointCut, before = emptyFunc) &#123; advice(target, pointCut, &#123;before&#125;); &#125;, after(target, pointCut, after = emptyFunc) &#123; advice(target, pointCut, &#123;after&#125;); &#125;, afterReturn(target, pointCut, afterReturn = emptyFunc) &#123; advice(target, pointCut, &#123;afterReturn&#125;); &#125;, afterThrow(target, pointCut, afterThrow = emptyFunc) &#123; advice(target, pointCut, &#123;afterThrow&#125;); &#125;, round(target, pointCut, round = emptyFunc) &#123; advice(target, pointCut, &#123;round&#125;); &#125;&#125;;export default aop; 现在我们的before可以简化成：123before(target, pointCut, before = emptyFunc) &#123; advice(target, pointCut, &#123;before&#125;);&#125; 使用方法前置before前置增强不干扰原方法的执行，只有一个参数为连接点信息，可以访问到切点所在的类和方法以及当前的参数和this引用。 12345import Test from './test';aop.before(Test, 'test', (joinPoint) =&gt; &#123; let &#123;target, method, args, self&#125; = joinPoint; console.log('test方法将被执行');&#125;); 后置after后置增强在原方法执行完毕后执行，参数除了连接点信息外还有返回结果和异常。因为原方法可能是正常返回也可能抛出异常，所以result和error有一个为空(AspectJ无此设计)。 12345import Test from './test';aop.after(Test, 'test', (joinPoint, result, error) =&gt; &#123; let &#123;target, method, args, self&#125; = joinPoint; console.log('test方法执行完毕');&#125;); 返回afterReturn返回增强可以拿到原方法的返回值，即回调的第二个参数。如果需要修改返回值，可以在增强里面return，否则使用原返回值。 1234567import Test from './test';aop.afterReturn(Test, 'test', (joinPoint, result) =&gt; &#123; let &#123;target, method, args, self&#125; = joinPoint; console.log('test方法正常执行完毕'); // 可以修改返回值 return newResult;&#125;); 异常afterThrow异常增强在原方法发生异常时执行，回调的第二个参数为异常。 并且回调可以方法布尔值，表示是否截断异常，当return true时异常不会继续上抛(AspectJ无此功能)。 12345import Test from './test';aop.afterThrow(Test, 'test', (joinPoint, error) =&gt; &#123; let &#123;target, method, args, self&#125; = joinPoint; console.log('test方法抛出异常');&#125;); 环绕around环绕增强是最灵活的方法，将原方法的执行权交给增强代码来调用，在连接点中多了一个handle方法，增强代码中手动调用handle方法，因此可以根据调用时机实现前面四种增强类型，并且可以定制原方法的参数和返回值。arround增强需要return结果给原方法的调用方 1234567891011import Test from './test';aop.around(Test, 'test', (joinPoint, error) =&gt; &#123; let &#123;target, method, args, self, handle&#125; = joinPoint; console.log('test方法即将执行'); let result = handle(); // 无参调用即使用原始参数调用原方法 // let result = handle(args) // 使用指定的参数调用原方法 // 可以对result进行处理 console.log('test方法执行完毕'); // 必须返回一个结果 return result;&#125;); 结尾得益于JavaScript语言的动态性，实现一个基础版功能过得去的AOP还是非常容易的，基本可以满足一般NodeJs、React Native等项目使用。 当然还有很多不足的地方，比如更灵活的切面等，如果大家用过AspectJ，可能会知道Aspect可以通过全程类名、特定注解、继承关系、模糊匹配等多种方式声明切点，无疑能使aop的使用更加灵活。另外也可以针对React的Component组件类aop做改进，这部分可以参考react-proxy实现。 后面可能会视应用场景逐渐优化和改进aop。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AOP</tag>
        <tag>Aspect</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js箭头函数的this]]></title>
    <url>%2F2019%2F06%2F02%2Fjs%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo首页文章摘要]]></title>
    <url>%2F2019%2F05%2F28%2FHexo%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[发现自己原来的博客首页把所有文章全部显示出来了，效果不大好，尤其是一篇长文章把其他的文章挤到好几屏都看不到。想办法改成折叠的预览效果，网上搜了一下，原来还挺简单的，在NexT的配置文件找到auto_excerpt，将enable改为true即可，效果如下。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建记录]]></title>
    <url>%2F2019%2F05%2F26%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Hexo博客搭建记录Hexo和GitHub PageHexo是一个流行的静态博客系统，GitHub Page是GitHub提供的静态页面托管服务，使用Hexo + GitHub Page的组合是个不错的个人博客尤其是技术博客的搭建方案。我个人认为有以下优点： GitHub在圈内认同度很高，在Google搜索的权重也非常高； 提供了GitHub的二级域名https://{username}.github.io，可以省去申请域名、备案、维护vps、申请https证书等等一系列烦恼； Hexo默认使用Markdown进行创作，对于涉及代码的技术博客排版友好； Hexo拥有丰富的主题和插件，可定制性强，相比简书、掘金等博客网站，更容易做出一个个性有范的博客； 可以方便的使用git进行版本控制； 缺点也是有的，Page毕竟是个静态托管服务，所以我们无法使用动态语言如Java、PHP等实现复杂功能；GitHub搭建的博客访问速度较慢，但是，翻Q是每个技术人必备的技能。 WordPress也是一个不错的博客系统，不过他是使用php动态语言，GitHub Page不支持，所以，这里也先不讨论WordPress了。 安装HexoHexo是一个Node.Js项目，等下要把静态博客推到GitHub上部署，所以确保电脑已经装了Node.Js、Git环境。环境准备完毕，直接使用下面的命令安装hexo即可。 1npm install -g hexo-cli 安装成功后，新建一个空文件夹作为博客根目录，在该目录下执行hexo init命令进行初始化，一个专属博客就创建好了。 使用命令hexo s运行项目，就可以通过localhost:4000访问我们的博客网站，默认创建了一篇”hello world”的博客。 现在，我们要把它部署到GitHub Page上。 新建GitHub Page仓库关于GitHub Page的介绍，可以看看官方文档。使用GitHub Page非常简单，只要在你的GitHub上建立一个名为{username}.github.io的空仓库，其中username是你的GitHub用户名，等下我们博客的访问路径也是{username}.github.io。 仓库中不需要存放文件，因为等下Hexo会通过Git部署插件自动把编译生成的静态博客推到这个仓库。 配置Git部署插件首先，安装这个插件，在博客根目录下执行命令 1npm install hexo-deployer-git --save 然后在根目录下的_config.yml文件夹下配置我们我们刚才创建的GitHub仓库。比如我的是: 1234deploy: type: git repo: git@github.com:huangmb/huangmb.github.io.git branch: master 这里的repo是仓库的clone地址，ssh格式而不是https，因为这里没有配置你的git账户信息。 然后执行hexo g -d命令即可发布文章到GitHub上，每次更新文章或者配置后，都可以用这个任务发布，然后在你的博客网站上立刻就能看到最新效果。 如果发布太频繁，可能对SEO不友好，或者容易产生浏览器缓存，如果发现网站没有更新不妨试试清理缓存或者强制刷新。 配置SSH为了方便Git部署插件，我们选择ssh的仓库地址，而不是https的仓库url。如果你曾经clone和push过自己GitHub名下的仓库，已经保存了GitHub账户信息也可以直接使用https的clone url，可以跳过这个步骤。 打开上面创建的仓库，点击clone or download按钮查看clone地址。如果你们配置过ssh，就会上面上面以”git@github.com“开头的url，直接使用这个url即可。否则会出现个选项配置ssh，其实就是这个路径https://github.com/settings/ssh/new 到电脑的用户目录下，查看隐藏文件夹.ssh/id_rsa.pub文件，将里面的内容拷贝到上面的Key输入框内，Title随便写。如果找不到.ssh文件夹或者文件夹下不存在id_rsa.pub文件，则是还未创建ssh公钥，关于git ssh可以参考这篇文章 服务器上的 Git - 生成 SSH 公钥 添加回到仓库中就能看到ssh的clone地址，填到hexo git插件配置文件中。 安装NexT主题默认的landspape我感觉不好看，好在Hexo有丰富的主题可选，这里我选了比较热门的NexT主题。就是你们看到的现在这个样子，使用的是NexT主题的Pisces模式，长这个样子。 下载主题Hexo的主题安装其实就是把主题包放在在themes文件夹下，每个主题一个文件夹。所以，安装NexT主题，你可以直接把https://github.com/theme-next/hexo-theme-next下载下来放在themes文件夹下。这里选择另外一种更好的方式，将NexT仓库使用Git clone到themes文件夹下： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 这样，当Next更新之后，只要使用git pull即可完成更新。 启用主题打开根目录下的_config.yml配置文件，找到theme字段，改为theme: next。重启博客服务，现在主题已经切换到NexT上了。NexT内置了Muse、Mist、Pisces、Gemini四种风格，可以在Next的配置文件/themes/next/_config.xml中找到下面的配置，注释其中一个验证一下效果。修改NexT配置可不需要重启即可看到效果。 1234# scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 下面介绍Hexo可能会定制的地方。后面Hexo的配置文件均是指根目录下的_config.yml，NexT的配置文件均是指/themes/next/_config.xml文件。 配置网站基本信息在Hexo的配置文件中，找到下面的site模块进行修改。12345678# Sitetitle: Bob Huang's Blogsubtitle: 很酷的Android工程师description: 没事瞎写keywords: Android,Kotlin,React Native,Spring MVC,NodeJsauthor: Bob Huanglanguage: zh-CNtimezone: asia/shanghai 因为要部署到GitHub上，这里记得把时区手动指定东八区。 配置头像在NexT的配置文件，找到下面的代码，把头像放到images文件夹下，通过url字段配置；rounded字段可以配置圆角。1234# Sidebar Avataravatar: url: /images/avatar.png rounded: true 配置菜单默认的菜单只有”首页”和”归档”，我们可以在NexT的配置文件中找到menu模块。 添加菜单12345678910menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive # schedule: /schedule/ || calendar about: /about/ || user #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 可以把预置的一些菜单去除注释，比如常用的分类和标签；也可以自己添加其他菜单，比如这里加的关于菜单。菜单的格式如下1name: path || icon 前面是菜单的名称，中间的对应的链接路径，||后面是图标的名字，可以去fontawesome.com上找合适的图标或者看看博客内其他地方在用的图标。 可能你会发现标签和分类两个菜单跳转会404，那是因为还没有创建标签和菜单。 新建标签执行命令 1hexo new page "tags" 会生成一个source/tags/index.md文件，将其改为:12345---title: 标签date: 2019-05-26 17:20:25type: "tags"--- 新建分类和标签类似，执行命令 1hexo new page "categories" 然后source/categories/index.md文件改成 12345---title: 文章分类date: 2019-05-26 17:07:32type: "categories"--- 现在标签和菜单不会404了。 配置GitHub等社交信息GitHub有两处地方可以配置，其一是博客右上角的这是在NexT配置文件的这部分进行修改：1234github_banner: enable: true permalink: https://github.com/huangmb title: Follow me on GitHub 另一个地方是左下角社交展示区域，可以添加GitHub以及邮箱等其他信息。 123456social: GitHub: https://github.com/huangmb || github E-Mail: mailto:286931810@qq.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter 搜索功能虽然是静态博客网站，Hexo也集成了一个本地搜索功能。使用下面的命令安装搜索模块： 1npm install hexo-generator-searchdb --save 然后在Next的配置文件找到local_search的配置项，将enable改为true即可，你会看到菜单中多了一项搜索。 开始创作完事具备，可以开始写作了。在Hexo中，文章是以Markdown方式保存的，所有文章都保存在source/_posts下 新建文章使用命令 1hexo new post "标题" 即可在_posts文件夹下生成对应的Markdown文件。你可以手动新建Markdown文件，并在文件头部加上博客的声明（称为Front Matter），比如现在这篇文章： 123456789---title: Hexo博客搭建记录date: 2019-05-26 16:59:36categories:- hexotags:- hexo- 记录--- 使用分类和标签正如上面的文件头声明，分类和标签仅需要加上categories和tags字段，标签可以声明多个，而分类声明多个是多级分类的意思，而不是多个分类。 创建时间和更新时间在文件头声明date和updated 更多可以使用的属性见front-matter 版权声明在NexT的配置文件中，找到creative_commons模块，将enable改为true即可。 使用评论本站使用的是Valine作为评论系统，好处是可以匿名评论，支持表情和Markdown。具体安装参考这篇文章。 使用赞赏在NexT的配置文件中找到reward_settings模块，将enable改为true，并在下面的reward中的支付宝和微信注释去掉，并改成你的支付宝和微信收款码图片文件名。将微信和支付宝的收款码放在source/images文件夹下。 数据统计字数统计在NexT的配置文件中，找到symbols_count_time，将各属性改为true即可。 1234567symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 suffix: mins. 访客量和访问量可以使用busuanzi统计，在NexT的配置文件中找到busuanzi_count并将enable改为true，则在网页底部会有访客统计数据。 如果需要修改显示的样式，比如加上标题，可以修改Next下的layout/_third_party/analytics/busuanzi-counter.swig模版。 百度统计前往官网添加一个网站，然后在代码获取下将hm.js后面的xxxx就是你的id拷贝下来。123var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?xxxx&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; 在NexT的配置文件中找到baidu_analytics，将注释去掉，值为刚才拷贝的ID。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2019%2F05%2F25%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello World!多么亲切的来自程序猿的问候。今天，终于开通了自己的博客，我会在这里和大家分享技术、经验以及一些唠嗑，欢迎大佬拍砖。后面文章会在这里首发，再同步到简书、掘金以及公众号上。 简书 https://www.jianshu.com/u/05f0e6a41c4e 掘金 https://juejin.im/user/5be44594e51d450e6f6618a5 公众号]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
